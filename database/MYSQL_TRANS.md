#### 事务特性

**原子性(atomicity)**

一个事务被视为不可分割的最小工作单元，要么全部成功，要么全部失败。

**一致性(consistency)**

数据库总会从一个一致性的状态切换至另外一个一致性状态，最小工作单元的失败会导致事务没有提交，事务中做的修改也不会保存到数据库。

**隔离性(isolation)**

一个事务所做的修改在最终提交之前对其他事务通常是不可见的。

**持久性(durability)**

一旦事务提交，则其所做的修改就会永远保存在数据库中。



#### 隔离级别

mysql 定义了4种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统开销也小。

PS：每种存储引擎实现的隔离级别不尽相同。

**未提交读(READ UNCOMMITTED)**

事务的修改即便没有提交，其他事务也是可见的。事务可以读取未提交的事务（脏读Dirty Read）

PS：这个事务级别会导致很多问题，从性能上来说不会比其他隔离级别好太多，但又缺乏其他级别的很多好处，实际应用一般很少使用。

**提交读(READ COMMITTED)（nonrepeatable read 不可重复读）**

大多数数据库的默认隔离级别（但MYSQL不是），READ COMMITED满足了事务特性种的隔离性的简单定义：一个事务开始时，只能看见已经提交的事务所做的修改。

**可重复读(REPEATABLE READ)**

REPEATABLE READ解决了脏读的问题，时MYSQL的默认隔离级别，该级别保证了在同一个事务中多次读取同样记录的结果是一致的，但是无法解决幻读(Phantom Read)的问题。

PS：幻读指的是当某个事务在读取某个范围内的记录时，另外一个事务又往该范围插入了新的记录，当之前的事务再次读取某个范围内的记录时会产生幻行(Phantom Row)。InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC Multiversion Concurrency Control)解决了幻读的问题。

**可串行化(SERIALIZABLE)**

最高隔离级别，通过强制事务串行执行，避免了幻读问题。简单说就是在读取每一行数据时都加锁，可能导致大量的超时和锁竞争问题，实际应用中很少用到该隔离级别。

<img src="all_images/image-20230214151957747.png" width=70% height=70% />

