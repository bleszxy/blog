[TOC]



# tomcat服务器I/O模型

## 单线程阻塞I/O

单线程阻塞I/O模型是最简单的一种服务器模型，只能同时处理一个客户端访问，并且在读写I/O操作上都是阻塞的，线程会一直在等待，多个客户端同时访问时就像队列一样串行处理连接，详见下图

<img src="all_images/image-20230214180843683.png" width=70% height=70% />





## 多线程阻塞I/O

针对单线程阻塞I/O的缺点，采用多线程的方式对其进行改进，核心原理为每个客户端分配一个线程，处理能力得到大幅提高，有较高的并发量但是服务器资源消耗较大，并且会有多线程切换成本，程序结构也更复杂。

<img src="all_images/image-20200617153234179.png" width=70% height=70% />





## 单线程非阻塞I/O

多线程阻塞I/O确实可以提高服务器端的并发处理能力，但是每个连接都需要一个线程负责I/O操作，当连接数过多会导致调用机器的线程数量太多，并且这些线程大部分时间处于等待状态，造成了极大的资源浪费。

单线程非阻塞I/O即一个线程维护多个客户端连接，在调用读取或写入后立即返回，而不会进入阻塞状态，检测套接字事件完成请求请求的接收响应。



**socket检测方式**

#### 应用程序遍历socket的事件检测

多个客户端向服务器请求时，服务器端会保存一个socket连接列表，应用层线程会对socket连接列表轮询，不断的尝试读取或写入数据，这样很好的利用了阻塞的时间，但是连接空闲时也会占用较多的cpu资源，并不太适合实际使用，改进方式为如下两种事件驱动的非阻塞方式。

<img src="all_images/image-20200617193140706.png" width=70% height=70% />



#### 内核遍历socket的事件检测

将socket的遍历操作下沉到操作系统内核，把对socket的遍历结果组成一系列的事件列表并返回给应用层处理。如图所示，应用层向内核请求读写事件列表，内核遍历socket列表后生成可读列表readList和可写列表writeList，readList或writeList标明了每个socket是否可读或可写,值为1代表为可读或可写，应用层遍历读写事件列表做对应的读写操作。

<img src="all_images/image-20200617194458559.png" width=70% height=70% />



这种方式有利于提高检测效率,但是它需要将所有连接的事件列表从传递到应用层，如果socket连接过多，内核复制会有不小的开销，另外活跃连接较少时，内核与应用层之间存在很多无效的数据副本，因为它将活跃的和不活跃的连接状态都复制到了应用层。



#### 内核基于回调的事件检测

遍历的方式检测socket是否可读可写是一种效率比较低的方式，不管是应用层还中遍历还是内核中遍历，可以通过回调函数的机制来优化遍历的方式。内核中的socket都对应一个回调函数，无论是客户端往socket发数据还是内核从网卡中接收数据后就调用回调函数，回调函数中维护事件列表，应用层获取此事件列表获取自己感兴趣的事情。详见下图

<img src="all_images/image-20200617202926355.png" width=70% height=70% />



方式1，仍有大量无用的数据（状态为0的元素）从内核中copy到应用层，方式2则只有自己感兴趣的事件。

图中两种方式均由操作系统维护客户端的所有连接并通过回调函数不断的更新事件列表，应用层线程只要遍历这些事件列表即可知道可读或可写的连接，极大的提高了检测效率。

对于java，非阻塞I/O的实现完全基于操作系统内核的非阻塞I/O并提供统一的api，在支持epoll的情况下优先选择，也就是1.15描述的事件检测方式。



单线程非阻塞I/O模型的主要优势体现在对多个连接的管理，一般在同时需要处理多个连接的场景中使用，该模型只使用1个线程维护所有连接，大大提高机器效率。



## 多线程非阻塞I/O模型

单线程非阻塞I/O模型已经大大提高了机器效率，而在多核机器上可以使用多线程继续提高机器效率，将客户端连接按组分配给若干线程，每个线程负责处理对应组内的连接。

<img src="all_images/image-20200619161944412.png" width=70% height=70% />



最经典的多线程非阻塞I/O模型方式为Reactor模式。

**单线程Reactor模式**

Reactor将服务器端的整个处理过程分为若干事件，例如accept、read、write、process事件，通过事件检测机制将这些事件分发给不同的处理器去处理，整个过程中只要有待处理的事件存在即可让Reactor线程不断往下执行而不会阻塞，所以处理效率很高。

<img src="all_images/image-20200619164533131.png" width=70% height=70% />



基于单线程Reactor模式，根据实际使用场景，将其改造为多线程模式。常见的方式有如下两种：

1、对于耗时较高的process处理器引入线程池，避免在单个Reactor线程中存在耗时的操作。

<img src="all_images/image-20200619165354160.png" width=70% height=70% />



2、直接使用多个Reactor实例，每个Reactor实例对应一个线程，由一个accept处理器接手客户端连接均匀非配给所有的Reactor实例。

<img src="all_images/image-20200619165413329.png" width=70% height=70% />



多线程非阻塞I/O模型让服务器端处理能力得到大大提供，充分利用机器的cpu，适合用于高并发场景，但是也让程序更复杂更容易出现问题。




